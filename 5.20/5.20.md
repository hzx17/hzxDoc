# typeOf 和 instanceOf 的区别
  - typeOf 是一个操作符，它能够判断number、string、boolean、undefined、object（function）、symbol。缺点是不能判断引用数据类型，如null、array、date（除function）等等。
  - instanceOf是一个关键字，他能够判断引用数据类型，但是不能判断基本数据类型。
  - 亮点：为什么typeOf(null)会返回object,这个算计算机早期设计的缺陷，32位存储，nul是000开头，表示未定义，所以也会返回Object

  - instanceOf 通常用来判断一个变量是否是某个对象的实例
  - instanceOf 返回的是一个boolean值

  - 实现一个typeOf
    ```js
      // object的原型上toString有类型的原型方法，call改变this指向，slice的作用是去掉[object ]
      Object.prototype.toString.call(value).slice(8,-1).toLowerCase()

    ```

    - 实现一个instanceOf
      ```js
        function instance_of(source, target) {
          // 如果是基本数据类型，直接返回false,
          if(typeof(source) !== 'object' || typeof(source) === null || typeof(source) !== 'function' ) return false
          // 向原型上查找
          let sourceProto = Object.getPrototypeOf(source)
          while (true) {
            // 最终到原型链顶端，null，返回true
            if(sourceProto === null) return false
            // 如果与原型相等，返回true
            if(sourceProto === Object.prototype(source)) return true
            // 否则继续向上查找
            sourceProto = Object.getPrototypeOf(sourceProto)
          }
        }
      ```

# 实现一个快速排序
  - 简单版
  ```js
  function sortArray(nums) {
        // 如果数组大小小于1，直接返回该数组
      if(nums.length <= 1) return nums
      // 寻找基数，一般来讲可以首尾中选中间值，这里直接用数组最中间的值
      let pivotIndex = Math.floor(nums.length / 2)

      let pivot = nums.splice(pivotIndex, 1)[0]
      // 定义左右数组，这样会占用空间
      let left = []
      let right = []
      for(let i = 0; i < nums.length; i++) {
          if(nums[i] < pivot) left.push(nums[i])
          else right.push(nums[i])
      }
      // 递归重新组合
      return sortArray(left).concat([pivot], sortArray(right))
  }
  ```
  - 原地交换
  ```js
    function ArrayList(arr) {
      this.items = arr
      // 快速排序
      ArrayList.prototype.quickSort = function () {
        this.quick(0, this.items.length -1)
        return this.items
      }
      // 将交换两个位置的方法抽取
      ArrayList.prototype.swap = function (m, n) {
        // 交换两个位置数据代码
        let temp = this.items[m]
        this.items[m] = this.items[n]
        this.items[n] = temp
      }
      ArrayList.prototype.quick = function (left, right) {
        if (left >= right) return
        let i = left
        let j = right
        while (i < j) {
          // 基数选择数组第一个
          while (i < j && this.items[left] <= this.items[j]) {
            --j
          }
          while (i < j && this.items[left] >= this.items[i]) {
            ++i
          }
          this.swap(i,j)
        }
        this.swap(left, i)
        this.quick(left, i-1)
        this.quick(i+1, right)
      }
    }

    const arr = new ArrayList([3, 44, 38, 5, 47, 15, 36, 26, 27])
    console.log(arr.quickSort())
  ```

# 回流和重绘的概念
  - 回流：当我们改变页面大小或者位置，会触发页面的重新布局。这个叫回流
  - 重绘：当我们改变元素的颜色、透明度等等，会触发页面的重新绘制，这个叫重绘
  - 由此可知，回流一定重绘，而重绘不一定会触发回流，我们在开发中要尽量减少回流和重绘的发生

# 隐藏元素的方法和区别
  - display: none; 隐藏元素，关闭布局，不占空间，会触发回流和重绘
  - visibility: hidden; 还会占空间，只是不让显示，与opacity: 0;的区别是不会响应元素事件
  - opacity: 0; 透明度为0，还可以点击
  - position: absolute; top: -9999px; 脱离文档流
  - z-index: -999; 元素在最底层，不占空间，会触发重绘
  - transform: scale(0); 缩小元素
  - clip-path: circle(0); 裁剪元素


